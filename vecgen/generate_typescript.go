package vecgen

import (
	"fmt"
	"io"
	"strings"

	"github.com/ncbray/compilerutil/writer"
)

var vectorComponents = []string{"x", "y", "z", "w"}

func vecTypeName(width int) string {
	return fmt.Sprintf("Vector%d", width)
}

func matrixTypeName(width int) string {
	return fmt.Sprintf("Matrix%d", width)
}

func dotExpr(first string, second string, width int, o *writer.TabbedWriter) {
	for i := 0; i < width; i++ {
		name := vectorComponents[i]
		if i != 0 {
			o.WriteString(" + ")
		}
		o.WriteString(fmt.Sprintf("%s.%s * %s.%s", first, name, second, name))
	}
}

func matrixSetter(values []string, o *writer.TabbedWriter) {
	o.WriteLine(fmt.Sprintf("this.setTo(%s)", strings.Join(values, ", ")))
}

func drop(mask []int, index int) []int {
	filtered := make([]int, len(mask)-1)
	out := 0
	for i := 0; i < len(mask); i++ {
		if i == index {
			continue
		}
		filtered[out] = mask[i]
		out += 1
	}
	return filtered
}

func generateText(expr Expr, outerPrec int) string {
	var text string
	prec := 20
	switch expr := expr.(type) {
	case *Atom:
		text = expr.Text
	case *GetComponent:
		text = expr.Object.CachedGetter[expr.Index]
	case *Mul:
		prec = 14
		text = fmt.Sprintf("%s * %s", generateText(expr.Left, prec), generateText(expr.Right, prec+1))
	case *Div:
		prec = 14
		text = fmt.Sprintf("%s / %s", generateText(expr.Left, prec), generateText(expr.Right, prec+1))
	case *Add:
		prec = 13
		text = fmt.Sprintf("%s + %s", generateText(expr.Left, prec), generateText(expr.Right, prec+1))
	case *Sub:
		prec = 13
		text = fmt.Sprintf("%s - %s", generateText(expr.Left, prec), generateText(expr.Right, prec+1))
	case *Neg:
		prec = 16
		text = fmt.Sprintf("-%s", generateText(expr.Expr, prec))
	default:
		panic(expr)
	}
	if prec < outerPrec {
		text = fmt.Sprintf("(%s)", text)
	}
	return text
}

func generateAccess(obj *Object, width int, col int, row int) Expr {
	return &GetComponent{Object: obj, Index: col + row*width}
}

func generateDetRec(obj *Object, width int, cols []int, rows []int) Expr {
	if len(cols) == 1 {
		return generateAccess(obj, width, cols[0], rows[0])
	}
	row := rows[0]
	dropRows := drop(rows, 0)
	var expr Expr
	for i := 0; i < len(cols); i++ {
		col := cols[i]
		dropCols := drop(cols, i)
		child := generateDetRec(obj, width, dropCols, dropRows)
		child = &Mul{Left: generateAccess(obj, width, col, row), Right: child}
		if i == 0 {
			expr = child
		} else if i%2 == 0 {
			expr = &Add{Left: expr, Right: child}
		} else {
			expr = &Sub{Left: expr, Right: child}
		}
	}
	return expr
}

func generateDet(obj *Object, width int) Expr {
	cols := make([]int, width)
	rows := make([]int, width)
	for i := 0; i < width; i++ {
		cols[i] = i
		rows[i] = i
	}
	return generateDetRec(obj, width, cols, rows)
}

func generateReducedDet(obj *Object, width int, drop_col int, drop_row int) Expr {
	cols := make([]int, width)
	rows := make([]int, width)
	for i := 0; i < width; i++ {
		cols[i] = i
		rows[i] = i
	}
	cols = drop(cols, drop_col)
	rows = drop(rows, drop_row)
	return generateDetRec(obj, width, cols, rows)
}

func bufferMatrix(src string, obj *Object, o *writer.TabbedWriter) {
	values := "v"
	o.WriteLine(fmt.Sprintf("const %s = %s.values;", values, src))

	t, ok := obj.Type.(*MatrixType)
	if !ok {
		panic(obj.Type)
	}
	width := t.Width
	for j := 0; j < width; j++ {
		for i := 0; i < width; i++ {
			index := i + j*width
			buffered := fmt.Sprintf("m%d%d", i, j)
			o.WriteLine(fmt.Sprintf("const %s = %s[%d];", buffered, values, index))
			obj.CachedGetter = append(obj.CachedGetter, buffered)
			obj.CachedSetter = append(obj.CachedSetter, fmt.Sprintf("%s[%d]", values, index))
		}
	}
}

func bufferVector(src string, obj *Object, o *writer.TabbedWriter) {
	t, ok := obj.Type.(*VectorType)
	if !ok {
		panic(obj.Type)
	}
	width := t.Width

	for i := 0; i < width; i++ {
		name := vectorComponents[i]
		o.WriteLine(fmt.Sprintf("const %s = %s.%s;", name, src, name))
		obj.CachedGetter = append(obj.CachedGetter, name)
		obj.CachedSetter = append(obj.CachedSetter, fmt.Sprintf("%s.%s", src, name))
	}
}

func GenerateTypeScript(out io.Writer) {
	o := writer.MakeTabbedWriter("  ", out)

	o.WriteLine("// Autogenerated, do not edit by hand.")

	vecType := map[int]*VectorType{}
	matType := map[int]*MatrixType{}
	for width := 2; width <= 4; width++ {
		vecType[width] = &VectorType{Width: width, Name: vecTypeName(width)}
		matType[width] = &MatrixType{Width: width, Name: matrixTypeName(width)}
	}

	// Vector types.
	for width := 2; width <= 4; width++ {
		vt := vecType[width]
		mt := matType[width]

		o.EndOfLine()
		o.WriteLine(fmt.Sprintf("export class %s {", vt.Name))
		o.Indent()
		for i := 0; i < width; i++ {
			o.WriteLine(fmt.Sprintf("%s:number = 0;", vectorComponents[i]))
		}

		o.EndOfLine()
		o.WriteString("setTo(")
		for i := 0; i < width; i++ {
			if i != 0 {
				o.WriteString(", ")
			}
			o.WriteString(fmt.Sprintf("%s:number", vectorComponents[i]))
		}
		o.WriteString(") {")
		o.EndOfLine()
		o.Indent()
		for i := 0; i < width; i++ {
			name := vectorComponents[i]
			o.WriteLine(fmt.Sprintf("this.%s = %s;", name, name))
		}
		o.WriteLine("return this;")
		o.Dedent()
		o.WriteLine("}")

		o.EndOfLine()
		o.WriteLine(fmt.Sprintf("dot(other:%s):number {", vt.Name))
		o.Indent()
		o.WriteString("return ")
		dotExpr("this", "other", width, o)
		o.WriteString(";")
		o.EndOfLine()
		o.Dedent()
		o.WriteLine("}")

		o.EndOfLine()
		o.WriteLine(fmt.Sprintf("normalize():%s {", vt.Name))
		o.Indent()

		self := &Object{Type: vt}
		bufferVector("this", self, o)

		var expr Expr
		for i := 0; i < width; i++ {
			child := &Mul{
				Left:  &GetComponent{Object: self, Index: i},
				Right: &GetComponent{Object: self, Index: i},
			}
			if i == 0 {
				expr = child
			} else {
				expr = &Add{
					Left:  expr,
					Right: child,
				}
			}
		}

		o.WriteString("const lsq = ")
		o.WriteString(generateText(expr, 0))
		o.WriteString(";")
		o.EndOfLine()

		o.WriteLine("const scale = lsq > 1e-30 ? 1 / Math.sqrt(lsq): 0;")
		for i := 0; i < width; i++ {
			o.WriteLine(fmt.Sprintf("%s = %s * scale;", self.CachedSetter[i], self.CachedGetter[i]))
		}

		o.WriteLine("return this;")
		o.Dedent()
		o.WriteLine("}")

		o.EndOfLine()
		o.WriteLine(fmt.Sprintf("transform(m:%s):%s {", mt.Name, vt.Name))
		o.Indent()
		self = &Object{Type: vt}
		m := &Object{Type: mt}
		bufferMatrix("m", m, o)
		bufferVector("this", self, o)

		for j := 0; j < width; j++ {
			var expr Expr
			for i := 0; i < width; i++ {
				child := &Mul{
					Left:  generateAccess(m, width, i, j),
					Right: &GetComponent{Object: self, Index: i},
				}
				if i == 0 {
					expr = child
				} else {
					expr = &Add{Left: expr, Right: child}
				}
			}
			o.WriteLine(fmt.Sprintf("%s = %s;", self.CachedSetter[j], generateText(expr, 0)))
		}
		o.WriteLine("return this;")
		o.Dedent()
		o.WriteLine("}")

		o.Dedent()
		o.WriteLine("}")
	}

	for width := 2; width <= 4; width++ {
		mt := matType[width]

		o.EndOfLine()
		o.WriteLine(fmt.Sprintf("export class %s {", mt.Name))
		o.Indent()
		// HACK no friends, so declare public.
		o.WriteLine("values:Float32Array;")

		o.EndOfLine()
		o.WriteLine("constructor() {")
		o.Indent()
		o.WriteLine(fmt.Sprintf("const v = new Float32Array(%d);", width*width))
		for i := 0; i < width; i++ {
			o.WriteLine(fmt.Sprintf("v[%d] = 1;", i*width+i))
		}
		o.WriteLine("this.values = v;")
		o.Dedent()
		o.WriteLine("}")

		o.EndOfLine()
		o.WriteString("setTo(")
		for j := 0; j < width; j++ {
			for i := 0; i < width; i++ {
				if i != 0 || j != 0 {
					o.WriteString(", ")
				}
				o.WriteString(fmt.Sprintf("m%d%d:number", i, j))
			}
		}
		o.WriteString(") {")
		o.EndOfLine()
		o.Indent()
		o.WriteLine("const v = this.values;")
		for j := 0; j < width; j++ {
			for i := 0; i < width; i++ {
				o.WriteLine(fmt.Sprintf("v[%d] = m%d%d;", i+j*width, i, j))
			}
		}
		o.Dedent()
		o.WriteLine("}")

		o.EndOfLine()
		o.WriteChunk(`
      copyToMemory(dst:Float32Array, offset:number) {
        dst.set(this.values, offset);
      }
      `)

		o.EndOfLine()
		o.WriteChunk(fmt.Sprintf(`
      copyFrom(other:%s) {
        this.values.set(other.values);
      }
      `, mt.Name))

		o.EndOfLine()
		o.WriteLine(fmt.Sprintf("invert():%s {", mt.Name))
		o.Indent()

		self := &Object{Type: mt}
		bufferMatrix("this", self, o)

		o.WriteLine(fmt.Sprintf("const det = %s;", generateText(generateDet(self, width), 0)))
		o.WriteLine("if (det != 0) {")
		o.Indent()
		for j := 0; j < width; j++ {
			for i := 0; i < width; i++ {
				d := generateReducedDet(self, width, i, j)
				if (i+j)%2 == 1 {
					d = &Neg{Expr: d}
				}
				d = &Div{Left: d, Right: &Atom{Text: "det"}}
				index := i + j*width
				o.WriteLine(fmt.Sprintf("%s = %s;", self.CachedSetter[index], generateText(d, 0)))
			}
		}

		o.Dedent()
		o.WriteLine("}")
		o.WriteLine("return this;")
		o.Dedent()
		o.WriteLine("}")

		if width == 4 {
			o.EndOfLine()
			o.WriteLine(fmt.Sprintf("ortho(l:number, r:number, t:number, b:number, n:number, f:number):%s {", mt.Name))
			o.Indent()
			matrixSetter([]string{
				"2 / (r - l)", "0", "0", "0",
				"0", "2 / (t - b)", "0", "0",
				"0", "0", "-2 / (f - n)", "0",
				"-(r + l) / (r - l)", "-(t + b) / (t - b)", "-(f + n) / (f - n)", "1",
			}, o)
			o.WriteLine("return this;")
			o.Dedent()
			o.WriteLine("}")
		}

		o.Dedent()
		o.WriteLine("}")
	}
}
